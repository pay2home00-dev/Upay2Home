// prisma/schema.prisma
// PostgreSQL (recommended). Adjust provider if needed.
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

/**
 * -------------------------
 * Auth.js / NextAuth v5 core
 * -------------------------
 * Matches the Prisma Adapter for Auth.js v5.
 */
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  userId        String?   @unique

  phone         String?
  kycVerified   Boolean   @default(false)

  role      Role    @default(USER)
  isBlocked Boolean @default(false)
  isDeleted Boolean @default(false)

  usdtBalance Decimal @default(0.0) @db.Decimal(38, 18)
  inrBalance  Decimal @default(0.0) @db.Decimal(38, 2)

  accounts        Account[]
  sessions        Session[]
  authenticators  Authenticator[]
  payoutProfiles  PayoutProfile[]
  inrTransactions INRTransaction[]

  totalConversions     Decimal @default(0.0) @db.Decimal(38, 2)
  pendingConversions   Decimal @default(0.0) @db.Decimal(38, 2)

  adminConfigsCreated AdminConfig[] @relation("AdminConfigCreatedBy")
  adminConfigsUpdated AdminConfig[] @relation("AdminConfigUpdatedBy")

  // ðŸ‘‡ Referral system
  referredById String?
  referredBy   User? @relation("UserReferrals", fields: [referredById], references: [id])
  referrals    User[] @relation("UserReferrals")

  // ðŸ‘‡ Add proper names for both sides of the relation
  referralBonusesEarned   ReferralBonus[] @relation("UserReferrerRelation")
  referralBonusesReceived ReferralBonus[] @relation("UserReferredRelation")

  resetPasswordToken     String?   // store hashed token
  resetPasswordTokenExpiry DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


enum Role {
  USER
  ADMIN
}

model ReferralBonus {
  id              String   @id @default(cuid())
  referrerId      String
  referredUserId  String
  depositId       String? 
  amountInr       Decimal  @db.Decimal(38, 2)
  bonusPercent    Decimal  @db.Decimal(5, 2)

  status          ReferralBonusStatus @default(PENDING)
  remarks         String?

  referrer     User       @relation("UserReferrerRelation", fields: [referrerId], references: [id], onDelete: Cascade)
  referredUser User       @relation("UserReferredRelation", fields: [referredUserId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  creditedAt DateTime?
}


enum ReferralBonusStatus {
  PENDING
  CREDITED
  CANCELLED
}


model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support (Auth.js)
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

/**
 * -------------------------
 * Admin config
 * -------------------------
 * A single row (or scoped rows) an admin can manage:
 * - USDT->INR conversion rate
 * - Toggle deposits/payouts
 * - Fees, limits
 */
model AdminConfig {
  id               String  @id @default(cuid())
  usdtToInrRate    Decimal @db.Decimal(38, 6)
  depositFeeBps    Int     @default(0)
  withdrawFeeBps   Int     @default(0)
  minDepositUSDT   Decimal @default(0.0) @db.Decimal(38, 18)
  minWithdrawINR   Decimal @default(0.0) @db.Decimal(38, 2)
  allowDeposits    Boolean @default(true)
  allowWithdrawals Boolean @default(true)
  bonusRatio       Decimal @default(0.0) @db.Decimal(38, 2)
  bonusRatioInr    Decimal @default(0.0) @db.Decimal(38, 2)
  notes            String?

  createdById String?
  updatedById String?
  createdBy   User?   @relation("AdminConfigCreatedBy", fields: [createdById], references: [id])
  updatedBy   User?   @relation("AdminConfigUpdatedBy", fields: [updatedById], references: [id])

  depositAddress String?
  qrCode         String?


  // contact us 
  telegram String?
  whatsapp String?

  // ðŸ‘‡ Add opposite relation for INRTransaction
  inrTransactions INRTransaction[]

  referralBonusPercent Decimal @default(1.0) @db.Decimal(5, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * -------------------------
 * User payout profiles
 * -------------------------
 * Users can store either UPI or Bank info (or both).
 * Only one active profile of each type can be enforced via unique compound index with isActive if desired.
 */
model PayoutProfile {
  id       String     @id @default(cuid())
  userId   String
  type     PayoutType
  isActive Boolean    @default(true)

  upiVpa        String?
  accountHolder String?
  accountNumber String?
  ifsc          String?
  bankName      String?
  branch        String?

  verified         Boolean @default(false)
  verificationNote String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // ðŸ‘‡ Opposite relation for INRTransaction
  inrTransactions INRTransaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, type, isActive])
}

enum PayoutType {
  UPI
  BANK
}

/**
 * -------------------------
 * INR transactions ledger
 * -------------------------
 * Tracks fiat side: conversions and withdrawals.
 * - CONVERT: when user converts USDT â†’ INR at current admin rate; debits USDT balance, credits INR balance
 * - WITHDRAW: when INR is sent to user's UPI/BANK; debits INR balance
 */

model INRTransaction {
  id            String             @id @default(cuid())
  userId        String
  type          INRTransactionType
  usdtAmount    Decimal?           @db.Decimal(38, 18)
  inrAmount     Decimal            @db.Decimal(38, 2)
  effectiveRate Decimal?           @db.Decimal(38, 6)
  feeInr        Decimal            @default(0.0) @db.Decimal(38, 2)

  relatedDepositId String?
  payoutProfileId  String?
  adminConfigId    String?
  partialAmount  Decimal?         @db.Decimal(38, 2)
  status      INRTransactionStatus @default(PENDING)
  providerRef String?
  remarks     String?

  executedAt  DateTime?
  completedAt DateTime?
  failedAt    DateTime?
  failReason  String?

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  payoutProfile  PayoutProfile? @relation(fields: [payoutProfileId], references: [id])
  adminConfig    AdminConfig?   @relation(fields: [adminConfigId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, type, status])
  @@index([payoutProfileId])
  @@index([relatedDepositId])
}

enum INRTransactionType {
  CONVERT
  WITHDRAW
}

enum INRTransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  PARTIAL
}
